<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>JVM学习笔记(三)——类加载机制 | Tie × Wiki</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.2"><link rel="stylesheet" type="text/css" href="//fastly.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//fastly.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//fastly.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//fastly.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="/css/prettify.css"><script type="text/javascript" src="//fastly.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//fastly.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//fastly.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.2.0"></head><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', '');
</script><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM学习笔记(三)——类加载机制</h1><a id="logo" href="/.">Tie × Wiki</a><p class="description">Later equals never</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/gallery/"><i class="fa fa-picture-o"> 相册</i></a><a href="/about/"><i class="fa fa-user-secret"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"> <h1 class="post-title">JVM学习笔记(三)——类加载机制</h1><div class="post-meta">July 2020</div><div class="post-content"><p><strong>虚拟机的类加载机制就是虚拟机把Java类的源码编译为<em>字节码</em>后，将其<em>读取进内存</em>，并对数据进行校验、转换解析和初始化、最终形成可以被虚拟机直接使用的Java类型。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200703214206.png" alt="类加载机制"></p>
<span id="more"></span>

<h2 id="一、类加载的时机"><a href="#一、类加载的时机" class="headerlink" title="一、类加载的时机"></a>一、类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>7个阶段。其中验证、准备、解析三个阶段统称为连接。<br><img src="https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p>
<blockquote>
<p>其中解析的阶段的顺序可能会发生变化，某些情况下可能会在初始化后再开始，另外<strong>注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段<strong>通常都是互相交叉地混合进行</strong>的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
</blockquote>
<p>什么时候需要进行类加载的第一个阶段是由<strong>虚拟机的具体实现来自由把握的</strong>。</p>
<p><br><br></p>
<hr>
<p><br><br></p>
<h2 id="二、类加载的过程"><a href="#二、类加载的过程" class="headerlink" title="二、类加载的过程"></a>二、类加载的过程</h2><h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是<strong>将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中</strong>，接着会为这个类在 <strong>JVM 的方法区创建一个对应的 Class 对象</strong>，这个 Class 对象就是这个类各种<strong>数据的访问入口</strong>。</p>
<ul>
<li><p>从哪里去加载字节码文件</p>
<ul>
<li>本地磁盘</li>
<li>网上加载.class文件（Applet）</li>
<li>从数据库中</li>
<li>压缩文件中（ZAR，jar等）</li>
<li>从其他文件生成的（JSP应用）</li>
</ul>
<p>  对于非数组类的加载阶段，可以使用系统提供的引导加载类，也可以使用自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。（重写一个类加载器的<code>loadClass()</code>方法）</p>
<p>  对于数组类，<strong>其本身由Java虚拟机直接创建的</strong>，但数据类的<strong>元素类型最终还是要靠类加载器去创建的</strong></p>
</li>
</ul>
<hr>
<h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。</p>
<p>其目的是<strong>确保Class文件中的字节流包含的信息符合档期那虚拟机的要求，并不会危害虚拟机自身的安全。</strong>对于虚拟机的类加载机制来说，验证阶段是非常重要的，但<strong>不是一定必要的</strong>，如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段可以考虑使用某些参数来关闭类验证，以缩短虚拟机类加载的时间。</p>
<p>验证阶段主要完成以下4个阶段的校验动作：</p>
<ol>
<li><p><strong>文件格式验证</strong><br> 验证字节流是否符合Class文件格式的规范，而且能够被当前版本的虚拟机处理，可能会包含以下验证点：</p>
<ul>
<li>是否以魔数<code>0cCAFEBABE</code>开头</li>
<li>主次版本号是否在当前虚拟机处理范围之类</li>
<li>常量池的常量中是否有不被支持的类型<br> ······</li>
</ul>
</li>
<li><p><strong>元数据验证</strong><br> 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，可能会包含以下验证点：</p>
<ul>
<li>这个类是否有父类（除java.lang.Object以外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不被允许的类（例如被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的所有方法</li>
<li>类中的字段是否会和父类产生矛盾（例如覆盖了父类的final字段，或者不符合规则的重载）<br> ······</li>
</ul>
</li>
<li><p><strong>字节码验证</strong><br> 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。保证被校验类在运行时不会做出危害虚拟机安全的事情，可能会包含以下验证点：</p>
<ul>
<li>保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现：在操作栈放置了一个int类型的数据，使用时却按照long类型载入本地变量表中</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换是有效的，比如不能把父类对象赋值给子类数据类型<br> ······</li>
</ul>
<p> 如果一个类通过字节码验证，<strong>也不能够说明其一定是安全的</strong></p>
<blockquote>
<p>“<strong>Halting Problem问题</strong>“：通过程序去校验程序逻辑是无法做到绝对准确的</p>
</blockquote>
</li>
<li><p><strong>符号应用验证</strong><br> 符号引用验证可以看做是类自身以外（常量池中的各种符号引用）的信息进行匹配性验证。可能会包含以下验证点：</p>
<blockquote>
<p>此阶段发生在虚拟机将符号应用转换为直接引用的时候，即发生在连接的第三阶段——解析阶段中。</p>
</blockquote>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问<br> ······</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h3><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即<strong>内存分配的对象</strong>以及<strong>变量初始值的设置。</strong></p>
<ul>
<li><p>内存分配的对象</p>
<p>  Java 中的变量有<strong>类变量</strong>和<strong>类成员变量</strong>两种类型，</p>
<p>  <strong>被static修饰的变量为类变量</strong>，<strong>而其他所有类型的变量都属类成员变量</strong>。在准备阶段，<strong>JVM 只会为类变量分配内存，而不会为类成员变量分配内存</strong>。</p>
<p>  <strong>类成员变量的内存分配需要等到初始化阶段和对象一起分配在Java堆中</strong></p>
</li>
<li><p>变量初始值的设置</p>
<p>  在准备阶段，JVM 会为类变量分配内存，并为其初始化。<strong>但是这里的初始化指的是为变量赋予Java语言中该数据类型的零值，而不是用户代码里初始化的值</strong>。</p>
<blockquote>
<p>例如<code>public static int value = 123;</code>那么变量在准备阶段过后的初始值是0而不是123，因为这时候尚未执行Java方法。</p>
</blockquote>
<p>  特殊情况：<br>  如果类字段的字段属性表中存在<code>ConstantValue</code>属性（例如 <strong>static final</strong>修饰的变量），那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</p>
</li>
</ul>
<hr>
<h3 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h3><p>解析阶段就是虚拟机将<strong>常量池内的符号引用替换为直接引用</strong>的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<blockquote>
<p>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p>
</blockquote>
<blockquote>
<p>直接应用：可以是直接执行目标的指针，相对偏移量或者一格能够直接定位到目标的句柄</p>
</blockquote>
<hr>
<h3 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h3><p>初始化时类加载过程的最后一步，到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。</p>
<p>对于初始化阶段，虚拟机<strong>严格规定了有且只有5中情况下必须对类进行初始化</strong>：</p>
<ul>
<li>遇到 <strong>new、getstatic、putstatic、invokestatic</strong> 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>使用new关键字实例化对象的时候、读取或设置一个类的静态字段</strong>（<strong>被final修饰、已在编译器把结果放入常量池的静态字段除外</strong>）的时候，以及调用一个类的静态方法的时候。</li>
<li><strong>使用 java.lang.reflect 包的方法对类进行反射调用</strong>的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现<strong>其父类还没有进行过初始化</strong>，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK1.7 动态语言支持时，如果一个 <strong>java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄</strong>，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>
</ul>
<br>

<p>接口的加载过程和类的加载过程<strong>稍有不同</strong>：</p>
<ul>
<li>接口中不能使用**static{}**语句块，但是编译器仍然会为接口生成<code>&lt;client&gt;()</code>类构造器，用于初始化接口中所定义的成员变量。</li>
<li>当一个类在初始化时，要求其父类全部已经都被初始化了，但是一个接口在初始化时，<strong>并不要求其父接口全部已经初始化，只有真正使用到父接口时才会被初始化</strong>。</li>
</ul>
<p>从另外一个角度来说：<strong>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>的过程</strong></p>
<ul>
<li><p><code>&lt;clinit&gt;()</code>类初始化方法，编译器会按照其出现顺序，收集<strong>类变量的赋值语句、静态代码块</strong>，最终组成类初始化方法。类初始化方法一般在<strong>类初始化的时候执行</strong>。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;init&gt;()</code>实例构造器，编译器会按照其出现顺序，收集<strong>成员变量的赋值语句、普通代码块</strong>，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在<strong>实例化类对象的时候执行</strong>。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法与实例构造器(<init>())方法不同，它不需要显式地调用父类构造器， 虚拟机会保证在<strong>子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</strong></p>
</li>
<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着<strong>父类中定义的静态语句块要优先于子类的变量赋值操作</strong>。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中能够被正确地加速、同步，<strong>如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法</strong>，其他线程都需要<strong>阻塞等待</strong>，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p>
</li>
</ul>
<hr>
<h3 id="2-6-使用"><a href="#2-6-使用" class="headerlink" title="2.6 使用"></a>2.6 使用</h3><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。</p>
<hr>
<h3 id="2-7-卸载"><a href="#2-7-卸载" class="headerlink" title="2.7 卸载"></a>2.7 卸载</h3><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。</p>
<p><br><br></p>
<hr>
<p><br><br></p>
<h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><blockquote>
<p><strong>通过一个类的全限定名来获取此类的二进制字节流并将其加载到JVM内存中，转化为Class对象</strong>，这个动作<strong>被放到Java虚拟机外部去实现</strong>，以便让应用程序自己决定如何去获取所需要的类，</p>
</blockquote>
<p>实现这个动作的代码模块被称为<strong>类加载器</strong>。</p>
<h3 id="3-1-类与类加载器"><a href="#3-1-类与类加载器" class="headerlink" title="3.1 类与类加载器"></a>3.1 类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用却远远不限于类加载阶段。</p>
<p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性</strong>，每一个类都拥有一个独立的类名称空间。</p>
<blockquote>
<p><strong>比较两个类是否相等，只有在这个两个类是由同一个类加载器加载的前提下才有意义</strong>，即使两个类来源于同一个Class文件，但是由于加载他们的类加载器不同，那么这两个类也必然不同。</p>
</blockquote>
<hr>
<h3 id="3-2-类加载的三种方式"><a href="#3-2-类加载的三种方式" class="headerlink" title="3.2 类加载的三种方式"></a>3.2 类加载的三种方式</h3><ul>
<li><p>通过命令行启动应用时由<strong>JVM初始化加载含有main()方法的主类</strong>。</p>
</li>
<li><p>通过<strong>Class.forName()方法动态加载</strong>，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</p>
</li>
<li><p>通过<strong>ClassLoader.loadClass()方法动态加载</strong>，不会执行初始化块。</p>
</li>
</ul>
<hr>
<h3 id="3-3-Java语言自带的三个类加载器"><a href="#3-3-Java语言自带的三个类加载器" class="headerlink" title="3.3 Java语言自带的三个类加载器"></a>3.3 Java语言自带的三个类加载器</h3><ul>
<li><p><strong>Bootstrap ClassLoader</strong> ：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath&#x2F;a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。（C++实现）</p>
</li>
<li><p><strong>Extention ClassLoader</strong> ：扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。</p>
</li>
<li><p><strong>Appclass Loader</strong>：也称为SystemAppClass。 加载当前应用的classpath的所有类</p>
</li>
</ul>
<hr>
<h3 id="3-4-双亲委派模型"><a href="#3-4-双亲委派模型" class="headerlink" title="3.4 双亲委派模型"></a>3.4 双亲委派模型</h3><p>应用程序都是由这<strong>三种类加载器互相配合进行加载的</strong>，如果有必要，我们还可以加入自定义的类加载器。</p>
<p><strong>这几种类加载器之间的层次关系，称为双亲委派模型。</strong></p>
<p>双亲委派模型要求<strong>除了顶层的启动加载器外，其余的类加载器都应当有自己的父类加载器</strong>。这里的<strong>类加载器之间的父子关系一般都不会以继承的关系来实现</strong>，而是都<strong>使用组合关系来复用父加载器的代码</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委派模型"></p>
<ul>
<li><p>双亲委派机制工作过程：</p>
<p>  如果一个类加载器收到了类加载的请求.它<strong>首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成,每个层次的类加载器都是如此</strong>.因此<strong>所有的加载请求最终都会传送到Bootstrap类加载器</strong>(启动类加载器)中.<strong>只有父类加载返回自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载</strong>。</p>
<blockquote>
<p>比如说，另外一个人给小费，自己不会先去直接拿来塞自己钱包，我们先把钱给领导，领导再给领导，一直到公司老板，老板不想要了，再一级一级往下分。老板要是要这个钱，下面的领导和自己就一分钱没有了。</p>
</blockquote>
</li>
</ul>
<br>

<blockquote>
<p>子类先委托父类加载</p>
</blockquote>
<blockquote>
<p>父类加载器有自己的加载范围，范围内没有找到，则不加载，<strong>并返回给子类</strong></p>
</blockquote>
<blockquote>
<p>子类在收到父类无法加载的时候，才会自己去加载</p>
</blockquote>
<ul>
<li>优势<br>  Java类随着它的类加载器一起具备了一种<strong>优先级的层次关系，保证了Java程序的稳定运行</strong>。<blockquote>
<p>例如无论哪一个类加载器加载一个类，最终都是委派到处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载环境中都是同一个类。相反，如果没有这种机制，由各个类自行去加载的话，那么系统中将会出现多个不同的Objec类，Java体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么<strong>类之间的比较结果及类的唯一性将无法保证</strong>，因此，为什么需要双亲委派模型？<strong>防止内存中出现多份同样的字节码</strong></p>
</blockquote>
<ul>
<li><p>双亲委派模型的实现</p>
<p>  先检查是否已经被加载过，若没有被加载过则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父类加载器，如果加载失败，则再调用自己的findClass()方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//先判断parent是否为空，如果不为空，先尝试用父类加载器加载；如果为空，则先尝试用类启动加载器加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException异常则说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果父类加载器没加载成功，则调用findClass尝试自己加载这个类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-5-破坏双亲委派模型"><a href="#3-5-破坏双亲委派模型" class="headerlink" title="3.5 破坏双亲委派模型"></a>3.5 破坏双亲委派模型</h3><p>在某些情况下<strong>父类加载器需要委托子类加载器去加载class文件</strong>。受到加载范围的限制，父类加载器无法加载到需要的文件。</p>
<blockquote>
<p>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p>
</blockquote>
<p><br><br></p>
<hr>
<p><br><br></p>
<h2 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h2><blockquote>
<p>转载自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html">JVM基础系列第7讲：JVM 类加载机制</a></p>
</blockquote>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello ShuYi.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的构造方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;price=&quot;</span> + price +<span class="string">&quot;,amount=&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">112</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后的输出字符串为</p>
<blockquote>
<p>书的静态代码块<br>Hello ShuYi.</p>
</blockquote>
<blockquote>
<p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（<strong>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</strong>），我们会进行类的初始化。初始化会按照顺序进行，</p>
</blockquote>
<p>并且此处没有 Book 类对象的实例化，所以<code>&lt;init&gt;()</code>方法不会被执行</p>
<hr>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爷爷在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是爸爸~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是儿子~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸的岁数:&quot;</span> + Son.factor);	<span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后的输出字符串为</p>
<blockquote>
<p>爷爷在静态代码块<br>爸爸在静态代码块<br>爸爸的岁数:25    </p>
</blockquote>
<br>

<p>也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？</p>
<p>这是因为<strong>对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）</strong>。因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<p>对面上面的这个例子，我们可以从入口开始分析一路分析下去：</p>
<blockquote>
<p>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。</p>
</blockquote>
<blockquote>
<p>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。</p>
</blockquote>
<blockquote>
<p>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。</p>
</blockquote>
<hr>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爷爷在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Grandpa</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是爷爷~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是爸爸~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子在静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是儿子~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>(); 	<span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的输出字符串为</p>
<blockquote>
<p>爷爷在静态代码块<br>爸爸在静态代码块<br>儿子在静态代码块<br>我是爷爷~<br>我是爸爸~<br>我是儿子~     </p>
</blockquote>
<br>

<blockquote>
<p>让我们仔细来分析一下上面代码的执行流程：</p>
</blockquote>
<blockquote>
<p>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。</p>
</blockquote>
<blockquote>
<p>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷」、「我是爸爸」、「我是儿子~」。</p>
</blockquote>
<hr>
<h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的构造方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;price=&quot;</span> + price +<span class="string">&quot;,amount=&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;书的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>书的普通代码块<br>书的构造方法<br>price&#x3D;110,amount&#x3D;0<br>书的静态代码块<br>书的静态方法     </p>
</blockquote>
<blockquote>
<p>下面我们一步步来分析一下代码的整个执行流程。<br>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。<br>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。</p>
</blockquote>
<blockquote>
<ul>
<li>当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器 。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器 ）。</li>
</ul>
</blockquote>
<blockquote>
<p>对于 Book 类，其类构造方法（）可以简单表示如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;书的静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">112</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于是首先执行<code>static Book book = new Book();</code>这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器 ，收集后的对象构造器 代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;书的普通代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line">Book()</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;书的构造方法&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;price=&quot;</span> + price +<span class="string">&quot;, amount=&quot;</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price&#x3D;110,amount&#x3D;0」。</p>
</blockquote>
<blockquote>
<p>当类实例化完成之后，JVM 继续进行类构造器的初始化：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();  <span class="comment">//完成类实例化</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;书的静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">112</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。</p>
</blockquote>
<blockquote>
<ul>
<li>到这里，类的初始化已经完成，JVM 执行 main 方法的内容。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">    staticFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即输出：「书的静态方法」。</p>
</blockquote>
<hr>
<h3 id="4-5-方法论"><a href="#4-5-方法论" class="headerlink" title="4.5 方法论"></a>4.5 方法论</h3><p>从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：</p>
<ol>
<li><p><strong>确定类变量的初始值</strong>。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</p>
</li>
<li><p><strong>初始化入口方法</strong>。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</p>
</li>
<li><p><strong>初始化类构造器</strong>。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</p>
</li>
<li><p><strong>初始化对象构造器</strong>。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。</p>
</li>
</ol>
<p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>
<p><br><br><br></p>
<hr>
<p><br><br><br></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><div style="margin-left: 5px  font-size:16px;">
[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>
[2]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html">https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html</a><br>
[3]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joemsu/p/9310226.html">https://www.cnblogs.com/joemsu/p/9310226.html</a><br>
[4]<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc</a><br>
[5]<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/100074023">https://blog.csdn.net/qq_41701956/article/details/100074023</a><br>
</div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.2" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.2"><p><span>发布时间: </span>2020-07-02  13:40:10</p><p><span>更新时间: </span>2022-04-21  16:20:39</p><p><span>本文链接: </span><a href="/posts/Code/181f0b61.html">https://wyatt.ink/posts/Code/181f0b61.html</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://wyatt.ink/posts/Code/181f0b61.html"></i></span></p><p><span>版权声明: </span>本博客所有文章除特别声明外，均采用 CC BY-SA 4.0 协议 ，转载请注明出处！</p></div><br><div class="tags"><a href="/tags/JVM/">JVM</a></div><div class="post-nav"><a class="pre" href="/posts/Code/1a4b62fe.html">单例模式</a><a class="next" href="/posts/Code/1e17e950.html">JVM学习笔记(二)——垃圾收集器和内存分配策略</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">一、类加载的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">二、类加载的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8A%A0%E8%BD%BD"><span class="toc-text">2.1 加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%AA%8C%E8%AF%81"><span class="toc-text">2.2 验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%87%86%E5%A4%87"><span class="toc-text">2.3 准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%A7%A3%E6%9E%90"><span class="toc-text">2.4 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.5 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BD%BF%E7%94%A8"><span class="toc-text">2.6 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%8D%B8%E8%BD%BD"><span class="toc-text">2.7 卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">三、类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">3.1 类与类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2 类加载的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Java%E8%AF%AD%E8%A8%80%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">3.3 Java语言自带的三个类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.4 双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.5 破坏双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">四、实例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1"><span class="toc-text">4.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2"><span class="toc-text">4.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3"><span class="toc-text">4.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4"><span class="toc-text">4.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="toc-text">4.5 方法论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Wyatt .</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/ThisisWyatt/hexo-maupassant"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.2" async></script><script type="text/javascript" src="//fastly.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.2" async></script><link rel="stylesheet" type="text/css" href="//fastly.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.2"><script type="text/javascript" src="/js/search.js?v=1.0.2"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="255,193,7" opacity="0.7" zIndex="-1" count="120" src="//fastly.jsdelivr.net/npm/canvas-nest.js/dist/canvas-nest.min.js" data-no-instant></script><script type="text/javascript" src="/js/copycode.js?v=1.0.2" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.2"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.2"></script><script type="text/javascript" src="/js/jquery.justifiedGallery.min.js"></script><script type="text/javascript" src="/js/albums.js"></script><script type="text/javascript" src="/js/prettify.js?v=1.0.2"></script><script>$(document).ready(function(){
$('pre').addClass('prettyprint');
//- $('code').addClass('prettyprint');
prettyPrint();
})
</script><script type="text/javascript" src="/js/toc.js?v=1.0.2" async></script></div></body></html>